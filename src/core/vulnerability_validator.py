"""
Multi-source vulnerability validation system.
Cross-references vulnerabilities across multiple sources for improved accuracy.
"""

import logging
from typing import Dict, List, Optional, Set, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import asyncio
from collections import defaultdict

from ..utils.version_parser import VulnerabilityVersionChecker

logger = logging.getLogger(__name__)


class VulnerabilitySource(Enum):
    """Enumeration of vulnerability sources."""
    GITHUB = "github"
    NIST_NVD = "nist_nvd"
    MITRE_CVE = "mitre_cve"
    SNYK = "snyk"
    EXPLOIT_DB = "exploit_db"


@dataclass
class VulnerabilityReport:
    """Individual vulnerability report from a source."""
    source: VulnerabilitySource
    cve_id: Optional[str] = None
    severity: Optional[str] = None
    description: str = ""
    affected_versions: List[str] = field(default_factory=list)
    confidence_score: float = 0.0
    url: Optional[str] = None
    raw_data: Dict = field(default_factory=dict)


@dataclass
class ConsolidatedVulnerability:
    """Consolidated vulnerability information from multiple sources."""
    cve_id: str
    sources: Set[VulnerabilitySource] = field(default_factory=set)
    reports: List[VulnerabilityReport] = field(default_factory=list)
    highest_severity: Optional[str] = None
    consensus_confidence: float = 0.0
    version_analysis: Dict = field(default_factory=dict)
    is_confirmed: bool = False


class VulnerabilityValidator:
    """Multi-source vulnerability validation system."""
    
    def __init__(self):
        self.version_checker = VulnerabilityVersionChecker()
        
        # Source reliability weights (based on accuracy analysis)
        self.source_weights = {
            VulnerabilitySource.GITHUB: 0.95,      # Highest accuracy, version-specific
            VulnerabilitySource.SNYK: 0.90,        # High accuracy, good version info
            VulnerabilitySource.NIST_NVD: 0.85,    # Comprehensive but sometimes unclear versions
            VulnerabilitySource.MITRE_CVE: 0.80,   # Good coverage but version parsing issues
            VulnerabilitySource.EXPLOIT_DB: 0.70   # Lower coverage but high confidence when found
        }
        
        # Severity mapping for consistency
        self.severity_mapping = {
            'critical': 5, 'high': 4, 'medium': 3, 'moderate': 3,
            'low': 2, 'info': 1, 'informational': 1, 'none': 0
        }
    
    def validate_vulnerabilities(
        self,
        package_name: str,
        package_version: str,
        vulnerability_reports: List[VulnerabilityReport]
    ) -> Dict[str, Union[List, Dict, float, bool]]:
        """
        Validate vulnerabilities across multiple sources.
        Returns consolidated analysis with confidence scoring.
        """
        if not vulnerability_reports:
            return {
                'package_name': package_name,
                'package_version': package_version,
                'total_vulnerabilities': 0,
                'confirmed_vulnerabilities': 0,
                'consolidated_vulnerabilities': [],
                'overall_confidence': 1.0,  # High confidence in "no vulnerabilities"
                'recommendation': 'SAFE',
                'requires_manual_review': False,
                'analysis_summary': 'No vulnerabilities reported by any source'
            }
        
        # Group reports by CVE ID
        cve_groups = self._group_by_cve(vulnerability_reports)
        
        # Consolidate each CVE group
        consolidated_vulns = []
        for cve_id, reports in cve_groups.items():
            consolidated = self._consolidate_cve_reports(cve_id, reports, package_name, package_version)
            consolidated_vulns.append(consolidated)
        
        # Calculate overall assessment
        return self._generate_overall_assessment(
            package_name, package_version, consolidated_vulns
        )
    
    def _group_by_cve(self, reports: List[VulnerabilityReport]) -> Dict[str, List[VulnerabilityReport]]:
        """Group vulnerability reports by CVE ID."""
        groups = defaultdict(list)
        
        for report in reports:
            # Use CVE ID if available, otherwise create unique identifier
            cve_id = report.cve_id or f"UNKNOWN_{report.source.value}_{hash(report.description)}"
            groups[cve_id].append(report)
        
        return dict(groups)
    
    def _consolidate_cve_reports(
        self,
        cve_id: str,
        reports: List[VulnerabilityReport],
        package_name: str,
        package_version: str
    ) -> ConsolidatedVulnerability:
        """Consolidate multiple reports for the same CVE."""
        consolidated = ConsolidatedVulnerability(cve_id=cve_id)
        consolidated.reports = reports
        consolidated.sources = {report.source for report in reports}
        
        # Determine highest severity
        severities = [report.severity for report in reports if report.severity]
        if severities:
            severity_scores = [self.severity_mapping.get(s.lower(), 0) for s in severities]
            max_severity_score = max(severity_scores)
            consolidated.highest_severity = next(
                s for s in severities 
                if self.severity_mapping.get(s.lower(), 0) == max_severity_score
            )
        
        # Calculate consensus confidence
        consolidated.consensus_confidence = self._calculate_consensus_confidence(reports)
        
        # Perform version analysis
        consolidated.version_analysis = self._analyze_version_applicability(
            reports, package_name, package_version
        )
        
        # Determine if vulnerability is confirmed
        consolidated.is_confirmed = self._is_vulnerability_confirmed(consolidated)
        
        return consolidated
    
    def _calculate_consensus_confidence(self, reports: List[VulnerabilityReport]) -> float:
        """Calculate confidence based on source consensus and reliability."""
        if not reports:
            return 0.0
        
        # Weight by source reliability
        total_weight = 0.0
        weighted_confidence = 0.0
        
        for report in reports:
            source_weight = self.source_weights.get(report.source, 0.5)
            report_confidence = report.confidence_score or 0.5
            
            total_weight += source_weight
            weighted_confidence += source_weight * report_confidence
        
        base_confidence = weighted_confidence / total_weight if total_weight > 0 else 0.0
        
        # Boost confidence if multiple sources agree
        source_count = len(set(report.source for report in reports))
        consensus_boost = min(0.2 * (source_count - 1), 0.4)  # Max 40% boost
        
        return min(base_confidence + consensus_boost, 1.0)
    
    def _analyze_version_applicability(
        self,
        reports: List[VulnerabilityReport],
        package_name: str,
        package_version: str
    ) -> Dict:
        """Analyze if the package version is affected by this vulnerability."""
        version_analyses = []
        
        for report in reports:
            if report.description:
                analysis = self.version_checker.check_vulnerability_applicability(
                    package_name, package_version, report.description, report.cve_id
                )
                version_analyses.append(analysis)
        
        if not version_analyses:
            return {
                'is_affected': None,
                'confidence_score': 0.0,
                'requires_manual_review': True,
                'analysis_method': 'no_version_info'
            }
        
        # Aggregate version analysis results
        affected_count = sum(1 for a in version_analyses if a['is_affected'])
        total_analyses = len(version_analyses)
        avg_confidence = sum(a['confidence_score'] for a in version_analyses) / total_analyses
        
        # Determine final assessment
        is_affected = affected_count > (total_analyses / 2)  # Majority rule
        requires_manual = any(a['requires_manual_review'] for a in version_analyses)
        
        return {
            'is_affected': is_affected,
            'confidence_score': avg_confidence,
            'requires_manual_review': requires_manual,
            'analysis_method': 'multi_source_consensus',
            'individual_analyses': version_analyses
        }
    
    def _is_vulnerability_confirmed(self, consolidated: ConsolidatedVulnerability) -> bool:
        """Determine if vulnerability is confirmed based on consensus and confidence."""
        # Require minimum confidence and source count
        min_confidence = 0.7
        min_sources = 1  # At least one reliable source
        
        high_reliability_sources = {
            VulnerabilitySource.GITHUB,
            VulnerabilitySource.SNYK,
            VulnerabilitySource.NIST_NVD
        }
        
        has_reliable_source = bool(consolidated.sources & high_reliability_sources)
        meets_confidence = consolidated.consensus_confidence >= min_confidence
        
        return has_reliable_source and meets_confidence
    
    def _generate_overall_assessment(
        self,
        package_name: str,
        package_version: str,
        consolidated_vulns: List[ConsolidatedVulnerability]
    ) -> Dict:
        """Generate overall vulnerability assessment."""
        total_vulns = len(consolidated_vulns)
        confirmed_vulns = [v for v in consolidated_vulns if v.is_confirmed]
        
        # Calculate overall confidence
        if not consolidated_vulns:
            overall_confidence = 1.0
        else:
            confidence_scores = [v.consensus_confidence for v in consolidated_vulns]
            overall_confidence = sum(confidence_scores) / len(confidence_scores)
        
        # Determine recommendation
        recommendation = self._determine_recommendation(consolidated_vulns)
        
        # Check if manual review is needed
        requires_manual_review = any(
            v.version_analysis.get('requires_manual_review', False)
            for v in consolidated_vulns
        )
        
        # Generate analysis summary
        summary = self._generate_analysis_summary(consolidated_vulns, confirmed_vulns)
        
        return {
            'package_name': package_name,
            'package_version': package_version,
            'total_vulnerabilities': total_vulns,
            'confirmed_vulnerabilities': len(confirmed_vulns),
            'consolidated_vulnerabilities': [self._serialize_vulnerability(v) for v in consolidated_vulns],
            'overall_confidence': overall_confidence,
            'recommendation': recommendation,
            'requires_manual_review': requires_manual_review,
            'analysis_summary': summary,
            'source_breakdown': self._generate_source_breakdown(consolidated_vulns)
        }
    
    def _determine_recommendation(self, consolidated_vulns: List[ConsolidatedVulnerability]) -> str:
        """Determine overall recommendation based on consolidated vulnerabilities."""
        if not consolidated_vulns:
            return 'SAFE'
        
        confirmed_vulns = [v for v in consolidated_vulns if v.is_confirmed]
        
        if not confirmed_vulns:
            # Check if any vulnerabilities need manual review
            manual_review_needed = any(
                v.version_analysis.get('requires_manual_review', False)
                for v in consolidated_vulns
            )
            return 'MANUAL_REVIEW' if manual_review_needed else 'SAFE'
        
        # Check severity of confirmed vulnerabilities
        high_severity_vulns = [
            v for v in confirmed_vulns
            if v.highest_severity and v.highest_severity.lower() in ['critical', 'high']
        ]
        
        if high_severity_vulns:
            return 'VULNERABLE_HIGH'
        elif confirmed_vulns:
            return 'VULNERABLE'
        else:
            return 'SAFE'
    
    def _generate_analysis_summary(
        self,
        all_vulns: List[ConsolidatedVulnerability],
        confirmed_vulns: List[ConsolidatedVulnerability]
    ) -> str:
        """Generate human-readable analysis summary."""
        if not all_vulns:
            return "No vulnerabilities found across all sources"
        
        total_count = len(all_vulns)
        confirmed_count = len(confirmed_vulns)
        
        if confirmed_count == 0:
            return f"{total_count} potential vulnerabilities found but none confirmed through cross-validation"
        
        severity_counts = defaultdict(int)
        for vuln in confirmed_vulns:
            if vuln.highest_severity:
                severity_counts[vuln.highest_severity.lower()] += 1
        
        severity_summary = ", ".join([
            f"{count} {severity}" for severity, count in severity_counts.items()
        ])
        
        return f"{confirmed_count} of {total_count} vulnerabilities confirmed: {severity_summary}"
    
    def _generate_source_breakdown(self, consolidated_vulns: List[ConsolidatedVulnerability]) -> Dict:
        """Generate breakdown of vulnerabilities by source."""
        source_counts = defaultdict(int)
        
        for vuln in consolidated_vulns:
            for source in vuln.sources:
                source_counts[source.value] += 1
        
        return dict(source_counts)
    
    def _serialize_vulnerability(self, vuln: ConsolidatedVulnerability) -> Dict:
        """Serialize consolidated vulnerability for output."""
        return {
            'cve_id': vuln.cve_id,
            'sources': [s.value for s in vuln.sources],
            'highest_severity': vuln.highest_severity,
            'consensus_confidence': vuln.consensus_confidence,
            'is_confirmed': vuln.is_confirmed,
            'version_analysis': vuln.version_analysis,
            'report_count': len(vuln.reports)
        }


class VulnerabilityAggregator:
    """Aggregate vulnerability reports from multiple scanners."""
    
    def __init__(self):
        self.validator = VulnerabilityValidator()
    
    async def aggregate_scan_results(
        self,
        package_name: str,
        package_version: str,
        scan_results: Dict[str, Dict]
    ) -> Dict:
        """
        Aggregate results from multiple vulnerability scanners.
        
        Args:
            package_name: Name of the package
            package_version: Version of the package
            scan_results: Dictionary with scanner results keyed by source name
        
        Returns:
            Consolidated vulnerability assessment
        """
        reports = []
        
        # Convert scanner results to VulnerabilityReport objects
        for source_name, result in scan_results.items():
            try:
                source = VulnerabilitySource(source_name.lower())
                report = self._convert_scan_result_to_report(source, result)
                if report:
                    reports.extend(report if isinstance(report, list) else [report])
            except ValueError:
                logger.warning(f"Unknown vulnerability source: {source_name}")
                continue
        
        # Validate and consolidate
        return self.validator.validate_vulnerabilities(package_name, package_version, reports)
    
    def _convert_scan_result_to_report(
        self,
        source: VulnerabilitySource,
        result: Dict
    ) -> Union[VulnerabilityReport, List[VulnerabilityReport], None]:
        """Convert scanner result to VulnerabilityReport format."""
        if not result or 'result' not in result:
            return None
        
        result_text = result['result']
        
        # Handle different result formats based on source
        if source == VulnerabilitySource.GITHUB:
            return self._parse_github_result(result_text, result.get('url'))
        elif source == VulnerabilitySource.NIST_NVD:
            return self._parse_nist_result(result_text, result.get('url'))
        elif source == VulnerabilitySource.MITRE_CVE:
            return self._parse_mitre_result(result_text, result.get('url'))
        elif source == VulnerabilitySource.SNYK:
            return self._parse_snyk_result(result_text, result.get('url'))
        elif source == VulnerabilitySource.EXPLOIT_DB:
            return self._parse_exploit_db_result(result_text, result.get('url'))
        
        return None
    
    def _parse_github_result(self, result_text: str, url: Optional[str]) -> Optional[VulnerabilityReport]:
        """Parse GitHub security advisory result."""
        if 'No published security advisories' in result_text:
            return None
        
        # Extract CVE information from GitHub result
        import re
        cve_match = re.search(r'CVE-\d{4}-\d+', result_text)
        severity_match = re.search(r'Severity:\s*(\w+)', result_text, re.IGNORECASE)
        
        return VulnerabilityReport(
            source=VulnerabilitySource.GITHUB,
            cve_id=cve_match.group(0) if cve_match else None,
            severity=severity_match.group(1) if severity_match else None,
            description=result_text,
            confidence_score=0.95,  # GitHub has high accuracy
            url=url
        )
    
    def _parse_nist_result(self, result_text: str, url: Optional[str]) -> List[VulnerabilityReport]:
        """Parse NIST NVD result."""
        if 'None found' in result_text:
            return []
        
        reports = []
        # NIST results often contain multiple CVEs
        import re
        cve_matches = re.findall(r'CVE-\d{4}-\d+', result_text)
        
        for cve_id in set(cve_matches):  # Remove duplicates
            reports.append(VulnerabilityReport(
                source=VulnerabilitySource.NIST_NVD,
                cve_id=cve_id,
                description=result_text,
                confidence_score=0.7,  # Lower confidence due to version checking issues
                url=url
            ))
        
        return reports
    
    def _parse_mitre_result(self, result_text: str, url: Optional[str]) -> List[VulnerabilityReport]:
        """Parse MITRE CVE result."""
        if 'None found' in result_text:
            return []
        
        reports = []
        import re
        
        # Extract severity if mentioned
        severity_match = re.search(r'(CRITICAL|HIGH|MEDIUM|LOW)', result_text, re.IGNORECASE)
        severity = severity_match.group(1) if severity_match else None
        
        # Extract CVE count
        cve_count_match = re.search(r'(\d+)\s+CVE', result_text)
        if cve_count_match:
            count = int(cve_count_match.group(1))
            # Create individual reports (simplified)
            for i in range(min(count, 10)):  # Limit to prevent too many entries
                reports.append(VulnerabilityReport(
                    source=VulnerabilitySource.MITRE_CVE,
                    severity=severity,
                    description=result_text,
                    confidence_score=0.6,
                    url=url
                ))
        
        return reports
    
    def _parse_snyk_result(self, result_text: str, url: Optional[str]) -> List[VulnerabilityReport]:
        """Parse SNYK result."""
        if 'None found' in result_text:
            return []
        
        reports = []
        import re
        
        # SNYK results format: "VULNERABLE - X SNYK vulnerabilities affect vX.X.X (Highest: SEVERITY)"
        vuln_match = re.search(r'(\d+)\s+SNYK.*Highest:\s*(\w+)', result_text, re.IGNORECASE)
        if vuln_match:
            count = int(vuln_match.group(1))
            severity = vuln_match.group(2)
            
            # Create simplified reports
            for i in range(min(count, 5)):  # Limit entries
                reports.append(VulnerabilityReport(
                    source=VulnerabilitySource.SNYK,
                    severity=severity,
                    description=result_text,
                    confidence_score=0.85,  # SNYK has good accuracy
                    url=url
                ))
        
        return reports
    
    def _parse_exploit_db_result(self, result_text: str, url: Optional[str]) -> Optional[VulnerabilityReport]:
        """Parse Exploit Database result."""
        if 'None found' in result_text:
            return None
        
        return VulnerabilityReport(
            source=VulnerabilitySource.EXPLOIT_DB,
            description=result_text,
            confidence_score=0.9,  # High confidence when exploits are found
            url=url
        )