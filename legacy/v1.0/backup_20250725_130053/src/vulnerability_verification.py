"""
IHACPA Python Package Security Automation - Vulnerability Scanner Verification
Browser Automation Script to Verify Scanner Accuracy

This script automates verification of our vulnerability scanners by:
1. Running our internal scanners on test packages
2. Using browser automation to scrape vulnerability databases directly
3. Comparing results to identify discrepancies
4. Generating comprehensive verification reports

Author: IHACPA Security Team
Version: 1.0.0
Created: 2024-12-XX
"""

import time
import json
import logging
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    from webdriver_manager.chrome import ChromeDriverManager
    SELENIUM_AVAILABLE = True
except ImportError:
    SELENIUM_AVAILABLE = False

import requests
from bs4 import BeautifulSoup
import re
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

from vulnerability_scanner import SynchronousVulnerabilityScanner, VulnerabilityScanner

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class VerificationResult:
    """Data class to store verification results for a package"""
    package_name: str
    version: str
    
    # Our scanner results
    our_nist_result: str
    our_mitre_result: str  
    our_snyk_result: str
    
    # Web scraping results
    web_nist_count: int
    web_mitre_count: int
    web_snyk_count: int
    
    # Status
    nist_match: bool
    mitre_match: bool
    snyk_match: bool
    
    # Notes
    notes: str = ""

class VulnerabilityVerification:
    """Automated verification system for vulnerability scanners"""
    
    def __init__(self):
        self.scanner = SynchronousVulnerabilityScanner()
        self.driver = None
        self.results = []
        
        # Test packages for verification
        self.test_packages = {
            'nist_nvd': [
                ('requests', '2.31.0'),
                ('numpy', '1.24.3'),
                ('flask', '2.3.2'),
                ('cryptography', '41.0.1'),
                ('urllib3', '2.0.3'),
                ('django', '4.2.3'),
                ('sqlalchemy', '2.0.19'),
                ('tensorflow', '2.13.0'),
                ('opencv-python', '4.8.0.74'),
                ('pandas', '2.0.3')
            ],
            'mitre_cve': [
                ('django', '4.2.3'),
                ('requests', '2.31.0'),
                ('jinja2', '3.1.2'),
                ('certifi', '2023.7.22'),
                ('setuptools', '68.0.0'),
                ('pip', '23.1.2'),
                ('wheel', '0.40.0'),
                ('six', '1.16.0'),
                ('pycrypto', '2.6.1'),
                ('lxml', '4.9.3')
            ],
            'snyk': [
                ('pyyaml', '6.0'),
                ('click', '8.1.6'),
                ('markupsafe', '2.1.3'),
                ('itsdangerous', '2.1.2'),
                ('blinker', '1.6.2'),
                ('babel', '2.12.1'),
                ('colorama', '0.4.6'),
                ('docutils', '0.20.1'),
                ('idna', '3.4'),
                ('packaging', '23.1')
            ]
        }
        
    def setup_browser(self):
        """Initialize Selenium WebDriver with appropriate options"""
        if not SELENIUM_AVAILABLE:
            logger.info("Selenium not available, using requests-only mode")
            self.driver = None
            return
            
        try:
            chrome_options = Options()
            chrome_options.add_argument("--headless")  # Run in background
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--disable-gpu")
            chrome_options.add_argument("--window-size=1920,1080")
            chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
            
            # Use webdriver-manager to handle ChromeDriver automatically
            self.driver = webdriver.Chrome(
                service=webdriver.chrome.service.Service(ChromeDriverManager().install()),
                options=chrome_options
            )
            self.driver.implicitly_wait(10)
            logger.info("Browser automation setup completed successfully")
            
        except Exception as e:
            logger.warning(f"Failed to setup browser: {str(e)}, falling back to requests-only mode")
            self.driver = None
            
    def cleanup_browser(self):
        """Clean up browser resources"""
        if self.driver:
            self.driver.quit()
            logger.info("Browser cleanup completed")
            
    def scrape_nist_nvd(self, package_name: str) -> int:
        """Scrape NIST NVD for vulnerability count"""
        if self.driver:
            return self._scrape_nist_nvd_selenium(package_name)
        else:
            return self._scrape_nist_nvd_requests(package_name)
    
    def _scrape_nist_nvd_selenium(self, package_name: str) -> int:
        """Scrape NIST NVD using Selenium"""
        try:
            url = f"https://nvd.nist.gov/vuln/search/results?form_type=Basic&results_type=overview&search_type=all&query={package_name}"
            logger.info(f"Scraping NIST NVD for {package_name}: {url}")
            
            self.driver.get(url)
            time.sleep(3)  # Wait for page load
            
            # Look for results count
            try:
                # Try multiple selectors for results count
                count_selectors = [
                    "span[data-testid='vuln-matching-records-count']",
                    ".searchResultsCount",
                    "#resultsTable_info",
                    "div[class*='search-results-count']"
                ]
                
                count = 0
                for selector in count_selectors:
                    try:
                        element = self.driver.find_element(By.CSS_SELECTOR, selector)
                        text = element.text
                        # Extract number from text like "Showing 1-20 of 150 results"
                        numbers = re.findall(r'\d+', text)
                        if numbers:
                            count = int(numbers[-1])  # Last number is usually total
                            break
                    except NoSuchElementException:
                        continue
                
                # If no count found, try counting table rows
                if count == 0:
                    rows = self.driver.find_elements(By.CSS_SELECTOR, "table tbody tr")
                    count = len(rows)
                    
                logger.info(f"NIST NVD scraping result for {package_name}: {count} vulnerabilities")
                return count
                
            except Exception as e:
                logger.warning(f"Could not extract count from NIST NVD for {package_name}: {str(e)}")
                return 0
                
        except Exception as e:
            logger.error(f"Error scraping NIST NVD for {package_name}: {str(e)}")
            return -1  # Error indicator
    
    def _scrape_nist_nvd_requests(self, package_name: str) -> int:
        """Scrape NIST NVD using requests (fallback method)"""
        try:
            url = f"https://nvd.nist.gov/vuln/search/results?form_type=Basic&results_type=overview&search_type=all&query={package_name}"
            logger.info(f"Scraping NIST NVD for {package_name} (requests): {url}")
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=30, verify=False)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Look for CVE entries in the HTML
            cve_links = soup.find_all('a', href=re.compile(r'CVE-\d{4}-\d+'))
            count = len(cve_links)
            
            # Alternative: look for vulnerability table rows
            if count == 0:
                vuln_rows = soup.select('table tbody tr')
                count = len(vuln_rows)
            
            logger.info(f"NIST NVD scraping result for {package_name}: {count} vulnerabilities")
            return count
            
        except Exception as e:
            logger.error(f"Error scraping NIST NVD for {package_name}: {str(e)}")
            return -1
            
    def scrape_mitre_cve(self, package_name: str) -> int:
        """Scrape MITRE CVE for vulnerability count"""
        if self.driver:
            return self._scrape_mitre_cve_selenium(package_name)
        else:
            return self._scrape_mitre_cve_requests(package_name)
    
    def _scrape_mitre_cve_selenium(self, package_name: str) -> int:
        """Scrape MITRE CVE using Selenium"""
        try:
            url = f"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword={package_name}"
            logger.info(f"Scraping MITRE CVE for {package_name}: {url}")
            
            self.driver.get(url)
            time.sleep(2)
            
            # Look for CVE entries
            try:
                # Count CVE links or entries
                cve_selectors = [
                    "a[href*='CVE-']",
                    "td[valign='top'] a",
                    "div[id*='cve'] a"
                ]
                
                count = 0
                for selector in cve_selectors:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    cve_links = [el for el in elements if 'CVE-' in el.get_attribute('href') or '']
                    if cve_links:
                        count = len(cve_links)
                        break
                
                # Alternative: count by page content
                if count == 0:
                    page_source = self.driver.page_source
                    cve_matches = re.findall(r'CVE-\d{4}-\d+', page_source)
                    count = len(set(cve_matches))  # Remove duplicates
                    
                logger.info(f"MITRE CVE scraping result for {package_name}: {count} vulnerabilities")
                return count
                
            except Exception as e:
                logger.warning(f"Could not extract count from MITRE CVE for {package_name}: {str(e)}")
                return 0
                
        except Exception as e:
            logger.error(f"Error scraping MITRE CVE for {package_name}: {str(e)}")
            return -1
    
    def _scrape_mitre_cve_requests(self, package_name: str) -> int:
        """Scrape MITRE CVE using requests (fallback method)"""
        try:
            url = f"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword={package_name}"
            logger.info(f"Scraping MITRE CVE for {package_name} (requests): {url}")
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=30, verify=False)
            response.raise_for_status()
            
            # Extract CVE identifiers from the response text
            cve_matches = re.findall(r'CVE-\d{4}-\d+', response.text)
            count = len(set(cve_matches))  # Remove duplicates
                    
            logger.info(f"MITRE CVE scraping result for {package_name}: {count} vulnerabilities")
            return count
                
        except Exception as e:
            logger.error(f"Error scraping MITRE CVE for {package_name}: {str(e)}")
            return -1
            
    def scrape_snyk(self, package_name: str) -> int:
        """Scrape SNYK for vulnerability count"""
        if self.driver:
            return self._scrape_snyk_selenium(package_name)
        else:
            return self._scrape_snyk_requests(package_name)
    
    def _scrape_snyk_selenium(self, package_name: str) -> int:
        """Scrape SNYK using Selenium"""
        try:
            url = f"https://security.snyk.io/package/pip/{package_name}"
            logger.info(f"Scraping SNYK for {package_name}: {url}")
            
            self.driver.get(url)
            time.sleep(3)
            
            try:
                # Check if package exists
                if "Package not found" in self.driver.page_source or "404" in self.driver.page_source:
                    logger.info(f"SNYK package not found: {package_name}")
                    return 0
                
                # Look for vulnerability count indicators
                vuln_selectors = [
                    ".vulnerabilities-count",
                    "[data-testid='vulnerabilities-count']",
                    ".vulnerability-list .vulnerability-item",
                    ".vuln-item",
                    "div[class*='vulnerability']"
                ]
                
                count = 0
                for selector in vuln_selectors:
                    try:
                        elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        if elements:
                            # Try to get count from text or count elements
                            if len(elements) == 1:
                                text = elements[0].text
                                numbers = re.findall(r'\d+', text)
                                if numbers:
                                    count = int(numbers[0])
                                    break
                            else:
                                count = len(elements)
                                break
                    except Exception:
                        continue
                
                # Check for "No vulnerabilities" message
                if count == 0:
                    no_vuln_indicators = [
                        "No vulnerabilities",
                        "no known vulnerabilities",
                        "0 vulnerabilities"
                    ]
                    page_text = self.driver.page_source.lower()
                    for indicator in no_vuln_indicators:
                        if indicator.lower() in page_text:
                            logger.info(f"SNYK confirmed no vulnerabilities for {package_name}")
                            return 0
                
                logger.info(f"SNYK scraping result for {package_name}: {count} vulnerabilities")
                return count
                
            except Exception as e:
                logger.warning(f"Could not extract count from SNYK for {package_name}: {str(e)}")
                return 0
                
        except Exception as e:
            logger.error(f"Error scraping SNYK for {package_name}: {str(e)}")
            return -1
    
    def _scrape_snyk_requests(self, package_name: str) -> int:
        """Scrape SNYK using requests (fallback method)"""
        try:
            url = f"https://security.snyk.io/package/pip/{package_name}"
            logger.info(f"Scraping SNYK for {package_name} (requests): {url}")
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=30, verify=False)
            
            # Check if package exists (404 or not found)
            if response.status_code == 404:
                logger.info(f"SNYK package not found: {package_name}")
                return 0
            
            response.raise_for_status()
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Look for vulnerability indicators in the HTML
            vuln_indicators = [
                "No known vulnerabilities",
                "no vulnerabilities",
                "0 vulnerabilities"
            ]
            
            page_text = soup.get_text().lower()
            for indicator in vuln_indicators:
                if indicator in page_text:
                    logger.info(f"SNYK confirmed no vulnerabilities for {package_name}")
                    return 0
            
            # Look for vulnerability entries
            vuln_elements = soup.find_all(['div', 'span', 'li'], class_=re.compile(r'vuln'))
            if vuln_elements:
                count = len(vuln_elements)
            else:
                # Try to find vulnerability count in text
                numbers = re.findall(r'(\d+)\s*vulnerabilit', page_text)
                count = int(numbers[0]) if numbers else 0
                    
            logger.info(f"SNYK scraping result for {package_name}: {count} vulnerabilities")
            return count
                
        except Exception as e:
            logger.error(f"Error scraping SNYK for {package_name}: {str(e)}")
            return -1
            
    def run_our_scanners(self, package_name: str, version: str) -> Tuple[str, str, str]:
        """Run our internal vulnerability scanners"""
        try:
            logger.info(f"Running our scanners for {package_name} v{version}")
            
            # Use async scanner directly since we're not in an event loop
            import asyncio
            scanner = VulnerabilityScanner()
            
            # Create new event loop for this scanner
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            try:
                results = loop.run_until_complete(scanner.scan_all_databases(package_name, current_version=version))
                
                # Extract summary messages for each scanner (results are nested under 'scan_results')
                scan_results = results.get('scan_results', {})
                nist_result = scan_results.get('nist_nvd', {}).get('summary', 'None found')
                mitre_result = scan_results.get('mitre_cve', {}).get('summary', 'None found') 
                snyk_result = scan_results.get('snyk', {}).get('summary', 'None found')
                
                return nist_result, mitre_result, snyk_result
                
            finally:
                # Clean up
                loop.run_until_complete(scanner.close())
                loop.close()
            
        except Exception as e:
            logger.error(f"Error running our scanners for {package_name}: {str(e)}")
            return "ERROR", "ERROR", "ERROR"
            
    def extract_count_from_result(self, result: str) -> int:
        """Extract vulnerability count from our scanner result string"""
        if not result or result in ['None found', 'ERROR', '']:
            return 0
            
        # Look for patterns like "15 CVEs found" or "VULNERABLE - 3 CVEs"
        numbers = re.findall(r'(\d+)\s+(?:CVEs?|vulnerabilit)', result, re.IGNORECASE)
        if numbers:
            return int(numbers[0])
            
        # Check for SAFE/VULNERABLE indicators
        if 'SAFE' in result.upper() or 'not affected' in result.lower():
            return 0
        elif 'VULNERABLE' in result.upper():
            # Try to extract count after VULNERABLE
            parts = result.split('-')
            for part in parts:
                numbers = re.findall(r'\d+', part)
                if numbers:
                    return int(numbers[0])
            return 1  # Assume at least 1 if marked vulnerable
            
        return 0
        
    def verify_package(self, package_name: str, version: str, scanner_type: str) -> VerificationResult:
        """Verify a single package across all scanners"""
        logger.info(f"Verifying {package_name} v{version} for {scanner_type}")
        
        # Run our scanners
        our_nist, our_mitre, our_snyk = self.run_our_scanners(package_name, version)
        
        # Extract counts from our results
        our_nist_count = self.extract_count_from_result(our_nist)
        our_mitre_count = self.extract_count_from_result(our_mitre)
        our_snyk_count = self.extract_count_from_result(our_snyk)
        
        # Scrape web sources
        web_nist_count = self.scrape_nist_nvd(package_name)
        time.sleep(2)  # Rate limiting
        
        web_mitre_count = self.scrape_mitre_cve(package_name)
        time.sleep(2)
        
        web_snyk_count = self.scrape_snyk(package_name)
        time.sleep(2)
        
        # Compare results
        nist_match = (our_nist_count == web_nist_count) or (web_nist_count == -1)
        mitre_match = (our_mitre_count == web_mitre_count) or (web_mitre_count == -1)
        snyk_match = (our_snyk_count == web_snyk_count) or (web_snyk_count == -1)
        
        # Create notes for discrepancies
        notes = []
        if not nist_match:
            notes.append(f"NIST: Our {our_nist_count} vs Web {web_nist_count}")
        if not mitre_match:
            notes.append(f"MITRE: Our {our_mitre_count} vs Web {web_mitre_count}")
        if not snyk_match:
            notes.append(f"SNYK: Our {our_snyk_count} vs Web {web_snyk_count}")
            
        result = VerificationResult(
            package_name=package_name,
            version=version,
            our_nist_result=our_nist,
            our_mitre_result=our_mitre,
            our_snyk_result=our_snyk,
            web_nist_count=web_nist_count,
            web_mitre_count=web_mitre_count,
            web_snyk_count=web_snyk_count,
            nist_match=nist_match,
            mitre_match=mitre_match,
            snyk_match=snyk_match,
            notes="; ".join(notes)
        )
        
        self.results.append(result)
        return result
        
    def run_full_verification(self):
        """Run complete verification across all test packages"""
        logger.info("Starting comprehensive vulnerability scanner verification")
        
        try:
            self.setup_browser()
            
            # Test all packages
            all_tests = []
            for scanner_type, packages in self.test_packages.items():
                for package_name, version in packages:
                    all_tests.append((package_name, version, scanner_type))
            
            total_tests = len(all_tests)
            logger.info(f"Running {total_tests} verification tests")
            
            for i, (package_name, version, scanner_type) in enumerate(all_tests):
                logger.info(f"Progress: {i+1}/{total_tests} - Testing {package_name}")
                try:
                    result = self.verify_package(package_name, version, scanner_type)
                    logger.info(f"Completed {package_name}: NIST={result.nist_match}, MITRE={result.mitre_match}, SNYK={result.snyk_match}")
                except Exception as e:
                    logger.error(f"Error verifying {package_name}: {str(e)}")
                    
        finally:
            self.cleanup_browser()
            
    def generate_report(self) -> str:
        """Generate comprehensive verification report"""
        if not self.results:
            return "No verification results available"
            
        report = []
        report.append("=" * 80)
        report.append("IHACPA VULNERABILITY SCANNER VERIFICATION REPORT")
        report.append("=" * 80)
        report.append(f"Total Packages Tested: {len(self.results)}")
        report.append(f"Test Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("")
        
        # Summary statistics
        nist_matches = sum(1 for r in self.results if r.nist_match)
        mitre_matches = sum(1 for r in self.results if r.mitre_match)
        snyk_matches = sum(1 for r in self.results if r.snyk_match)
        
        report.append("SUMMARY STATISTICS:")
        report.append(f"NIST NVD Accuracy: {nist_matches}/{len(self.results)} ({nist_matches/len(self.results)*100:.1f}%)")
        report.append(f"MITRE CVE Accuracy: {mitre_matches}/{len(self.results)} ({mitre_matches/len(self.results)*100:.1f}%)")
        report.append(f"SNYK Accuracy: {snyk_matches}/{len(self.results)} ({snyk_matches/len(self.results)*100:.1f}%)")
        report.append("")
        
        # Detailed results
        report.append("DETAILED RESULTS:")
        report.append("-" * 80)
        
        for result in self.results:
            report.append(f"\nPackage: {result.package_name} v{result.version}")
            report.append(f"NIST NVD: Our={self.extract_count_from_result(result.our_nist_result)} | Web={result.web_nist_count} | Match={result.nist_match}")
            report.append(f"MITRE CVE: Our={self.extract_count_from_result(result.our_mitre_result)} | Web={result.web_mitre_count} | Match={result.mitre_match}")
            report.append(f"SNYK: Our={self.extract_count_from_result(result.our_snyk_result)} | Web={result.web_snyk_count} | Match={result.snyk_match}")
            if result.notes:
                report.append(f"Notes: {result.notes}")
        
        # Discrepancies section
        discrepancies = [r for r in self.results if not (r.nist_match and r.mitre_match and r.snyk_match)]
        if discrepancies:
            report.append("\n" + "=" * 40 + " DISCREPANCIES " + "=" * 40)
            for result in discrepancies:
                report.append(f"\n{result.package_name} v{result.version}:")
                if not result.nist_match:
                    report.append(f"  NIST: Our {self.extract_count_from_result(result.our_nist_result)} != Web {result.web_nist_count}")
                if not result.mitre_match:
                    report.append(f"  MITRE: Our {self.extract_count_from_result(result.our_mitre_result)} != Web {result.web_mitre_count}")
                if not result.snyk_match:
                    report.append(f"  SNYK: Our {self.extract_count_from_result(result.our_snyk_result)} != Web {result.web_snyk_count}")
        
        return "\n".join(report)
        
    def save_report(self, filename: str = None):
        """Save verification report to file"""
        if filename is None:
            filename = f"vulnerability_verification_report_{time.strftime('%Y%m%d_%H%M%S')}.txt"
            
        report = self.generate_report()
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report)
            
        logger.info(f"Verification report saved to: {filename}")
        return filename

if __name__ == "__main__":
    """Main execution for verification testing"""
    verifier = VulnerabilityVerification()
    
    try:
        logger.info("Starting automated vulnerability scanner verification")
        verifier.run_full_verification()
        
        report_file = verifier.save_report()
        print(f"\nVerification completed! Report saved to: {report_file}")
        
        # Print summary
        print("\n" + "=" * 60)
        print("VERIFICATION SUMMARY")
        print("=" * 60)
        print(verifier.generate_report().split("DETAILED RESULTS:")[0])
        
    except Exception as e:
        logger.error(f"Verification failed: {str(e)}")
        raise